deimport static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.*;

import org.junit.jupiter.api.Test;
import org.mockito.ArgumentMatchers;
import java.net.PasswordAuthentication;
import java.net.http.HttpClient;
import java.net.http.HttpRequest;
import java.net.http.HttpResponse;
import java.util.HashMap;
import java.util.Map;

public class YourClassTest {

    @Test
    void testGetTokenFromOud_Successful() throws Exception {
        // Mocking HttpClient
        HttpClient mockedHttpClient = mock(HttpClient.class);
        when(mockedHttpClient.send(any(HttpRequest.class), ArgumentMatchers.<HttpResponse.BodyHandler<String>>any()))
                .thenReturn(HttpResponse.newBuilder()
                        .statusCode(200)
                        .body("{\"access_token\": \"your_token_value\"}")
                        .build());

        // Mocking System.currentTimeMillis() for elapsed time
        System mockedSystem = mock(System.class);
        when(mockedSystem.currentTimeMillis()).thenReturn(0L, 100L); // Assuming 100 ms elapsed time

        YourClass yourClass = new YourClass(mockedHttpClient, mockedSystem);
        
        // Test
        Either<String, FabricError> result = yourClass.getTokenFromOud("testUser", "testPassword", true);

        // Assertions
        assertEquals("your_token_value", result.getLeft());
    }

    @Test
    void testGetTokenFromOud_Failure() throws Exception {
        // Mocking HttpClient
        HttpClient mockedHttpClient = mock(HttpClient.class);
        when(mockedHttpClient.send(any(HttpRequest.class), ArgumentMatchers.<HttpResponse.BodyHandler<String>>any()))
                .thenReturn(HttpResponse.newBuilder()
                        .statusCode(500)
                        .body("Error Message")
                        .build());

        // Mocking System.currentTimeMillis() for elapsed time
        System mockedSystem = mock(System.class);
        when(mockedSystem.currentTimeMillis()).thenReturn(0L, 100L); // Assuming 100 ms elapsed time

        YourClass yourClass = new YourClass(mockedHttpClient, mockedSystem);

        // Test
        Either<String, FabricError> result = yourClass.getTokenFromOud("testUser", "testPassword", true);

        // Assertions
        assertEquals("HTTP Status Code : 500:Error Message", result.getRight().getMessage());
    }
}



import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.Mockito.*;

import com.scb.bpsi.grpc.clients.async.BiDiAsyncResponseHandler;
import com.scb.bpsi.v2.proto.query.QueryResponse;
import com.scb.cat.common.logging.LoggerFactory;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import java.nio.charset.StandardCharsets;
import java.util.Collections;
import java.util.concurrent.CountDownLatch;

class DALHandlerTest {

    private DALHandler dalHandler;
    private CountDownLatch completedLatch;
    private CallBackHandler<String> callBackHandler;

    @BeforeEach
    void setUp() {
        LoggerFactory loggerFactory = mock(LoggerFactory.class);
        completedLatch = mock(CountDownLatch.class);
        callBackHandler = mock(CallBackHandler.class);
        dalHandler = new DALHandler(loggerFactory, completedLatch, callBackHandler);
    }

    @Test
    void onNext_SuccessfulResponse() {
        QueryResponse queryResponse = QueryResponse.newBuilder()
                .setSuccess(true)
                .addData(QueryResponse.Data.newBuilder().setDetail(QueryResponse.Detail.newBuilder().setData("test data")))
                .build();

        dalHandler.onNext(queryResponse);

        assertEquals(Collections.singletonList("test data"), dalHandler.getResponseList());
    }

    @Test
    void onNext_UnsuccessfulResponse() {
        QueryResponse queryResponse = QueryResponse.newBuilder().setSuccess(false).build();

        dalHandler.onNext(queryResponse);

        // Assert that the responseList remains empty for unsuccessful responses
        assertEquals(Collections.emptyList(), dalHandler.getResponseList());
    }

    @Test
    void onCompleted() {
        dalHandler.onCompleted();

        // Verify that the logger and completedLatch are called appropriately
        verify(dalHandler.getLogger(), times(1)).info(anyString(), anyInt());
        verify(completedLatch, times(1)).countDown();
        verify(callBackHandler, times(1)).fillData(anyList());
    }

    @Test
    void onError() {
        Throwable throwable = new RuntimeException("Test error");

        dalHandler.onError(throwable);

        // Verify that the logger and completedLatch are called appropriately
        verify(dalHandler.getLogger(), times(1)).error(anyString(), eq(throwable.getMessage()));
        verify(completedLatch, times(1)).countDown();
    }
}


import com.scb.cat.common.config.Config;
import com.scb.cat.common.logging.LoggerFactory;
import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

import static org.junit.jupiter.api.Assertions.assertEquals;
import static org.mockito.ArgumentMatchers.any;
import static org.mockito.Mockito.*;

public class GrpcClientTest {

    @Mock
    private LoggerFactory loggerFactory;

    @Mock
    private Config config;

    @Mock
    private DALClient dalClient;

    @Mock
    private DALHandler dalHandler;

    private GrpcClient grpcClient;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
        grpcClient = new GrpcClient(loggerFactory, config);
    }

    @Test
    void testProcessQuery_Success() throws Exception {
        when(config.get(any())).thenReturn("dummyValue");
        when(dalClient.queryDomainJsonPathFilter(any(), any(), anyBoolean(), any(), any())).thenReturn("dummyResponse");
        when(loggerFactory.create(GrpcClient.class)).thenReturn(mock(Logger.class));

        grpcClient.processQuery(QueryType.CLIMATERISK, new HashMap<>());

        // You might need additional verification based on your actual implementation
        verify(loggerFactory, times(1)).create(GrpcClient.class);
        verify(dalClient, times(1)).queryDomainJsonPathFilter(any(), any(), anyBoolean(), any(), any());
        verify(dalHandler, times(1)).getCompletedLatch();
    }

    @Test
    void testProcessQuery_Exception() throws Exception {
        when(config.get(any())).thenReturn("dummyValue");
        when(dalClient.queryDomainJsonPathFilter(any(), any(), anyBoolean(), any(), any())).thenThrow(new RuntimeException("Test Exception"));
        when(loggerFactory.create(GrpcClient.class)).thenReturn(mock(Logger.class));

        List<String> result = grpcClient.processQuery(QueryType.CLIMATERISK, new HashMap<>());

        assertEquals(0, result.size()); // Ensure that no responses are added in case of an exception
        verify(loggerFactory, times(1)).create(GrpcClient.class);
        verify(dalClient, times(1)).queryDomainJsonPathFilter(any(), any(), anyBoolean(), any(), any());
        verify(dalHandler, times(0)).getCompletedLatch(); // Verify that the latch is not awaited in case of an exception
    }

    // Add more tests based on your specific use cases and edge scenarios
}


///


import static org.mockito.ArgumentMatchers.anyLong;
import static org.mockito.Mockito.*;

import org.junit.jupiter.api.BeforeEach;
import org.junit.jupiter.api.Test;
import org.mockito.Mock;
import org.mockito.MockitoAnnotations;
import org.slf4j.Logger;

import java.util.concurrent.CountDownLatch;
import java.util.concurrent.TimeUnit;

public class GrpcClientTest {

    @Mock
    private LoggerFactory loggerFactory;

    @Mock
    private Logger logger;

    private GrpcClient grpcClient;

    @BeforeEach
    void setUp() {
        MockitoAnnotations.openMocks(this);
        grpcClient = new GrpcClient(loggerFactory, config);
    }

    @Test
    void testWaitQuietlyForCompletionLatch_Successful() {
        CountDownLatch countDownLatch = new CountDownLatch(1);

        when(loggerFactory.create(any())).thenReturn(logger);

        // Run waitQuietlyForCompletionLatch in a separate thread
        new Thread(() -> grpcClient.waitQuietlyForCompletionLatch(5, countDownLatch)).start();

        // CountDownLatch is decremented in a separate thread, so we wait a bit for the latch to be counted down
        try {
            Thread.sleep(1000);
        } catch (InterruptedException e) {
            e.printStackTrace();
        }

        // CountDownLatch is counted down, so the logger should be called with the success message
        verify(logger, times(1)).info(eq("Client has successfully retrieved all the data from server within the time, "
                + "maximum time allowed for each data query is {}s "), eq(5L));
    }

    @Test
    void testWaitQuietlyForCompletionLatch_Timeout() {
        CountDownLatch countDownLatch = new CountDownLatch(0);

        when(loggerFactory.create(any())).thenReturn(logger);

        // Run waitQuietlyForCompletionLatch with a CountDownLatch that will not be counted down
        grpcClient.waitQuietlyForCompletionLatch(1, countDownLatch);

        // The logger should be called with the timeout warning message
        verify(logger, times(1)).warn(eq("Client has not finished the data query in allowed time, "
                + "maximum time allowed for each data query is {}s "), eq(1L));
    }
}

