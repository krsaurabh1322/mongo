Schema design for versioning and historical records in MongoDB

A single collection for both the main data and the historical records.
By using a separate version field and a history array, we can track the document's changes over time 
while keeping the _id field consistent.

db.counterparties.insertOne({
  _id: 1,
  counterparty_id: 1,
  version: 2,
  name: "Counterparty 1",
  address: "Address 1 New",
  startdate: ISODate("2023-07-10T09:30:00Z"),
  history: [
    {
      counterparty_id: 1,
      version: 1,
      name: "Counterparty 1",
      address: "Address 1",
      startdate: ISODate("2023-07-03T10:30:00Z"),
      closedate: ISODate("2023-07-10T09:30:00Z")      
    },
    // Other historical versions
  ]
})

OR
We can keep the main data collection separate from the historical records collection, thus
providing better organization and potentially optimizing performance.

db.counterparties.insertOne({
  _id: 1, // Unique identifier for the counterparty
  counterparty_id: 1,
  name: "Counterparty 1",
  address: "Address 1 New",
  startdate: ISODate("2023-07-10T09:30:00Z"),
  version: 2 // Current version number of the counterparty record
})

db.counterparties_history.insertOne({
  _id: ObjectId(), // a new unique identifier for each historical record or use counterparty_id and version as composite primary key
  counterparty_id: 1,
  version: 1,
  name: "Counterparty 1",
  address: "Address 1",
  startdate: ISODate("2023-07-03T10:30:00Z"),
  closedate: ISODate("2023-07-10T09:30:00Z")  
})

Schema for both the main table (counterparties) and the historical table (counterparties_history)

CREATE TABLE counterparties (
  counterparty_id VARCHAR(100) PRIMARY KEY,
  name VARCHAR(100),
  address VARCHAR(1000),
  startdate TIMESTAMP,
  closedate TIMESTAMP
);

CREATE TABLE counterparties_history (
  id VARCHAR(100) PRIMARY KEY, // counterparty_id and version together form the composite primary key
  counterparty_id VARCHAR(100),
  version INTEGER,
  name VARCHAR(100),
  address VARCHAR(1000),
  startdate TIMESTAMP,
  closedate TIMESTAMP,
  FOREIGN KEY (counterparty_id) REFERENCES counterparties (counterparty_id)
);

An implemenatin of update method for Mongodb:

Retrieves the document from Hazelcast, if the document is not found in Hazelcast, it falls back to retrieving it from MongoDB.
Clones the existing document to create a historical record.
Gets the current version and increments it.
Updates the version and data fields in the document with the new values.
Creates a new historical version with the previous version number, current timestamp, and the data from the cloned document.
Adds the historical version to the history array of the cloned document.
Replaces the document in MongoDB with the updated version.
Updates the document in Hazelcast.
Inserts the historical record into the MongoDB collection.

import com.hazelcast.core.HazelcastInstance;
import com.hazelcast.core.IMap;
import com.mongodb.client.MongoCollection;
import com.mongodb.client.MongoDatabase;
import org.bson.Document;

import java.util.Date;

public class MongoDBVersioningExample {
    private final HazelcastInstance hazelcastInstance;
    private final MongoDatabase mongoDatabase;
    private final String collectionName;

    public MongoDBVersioningExample(HazelcastInstance hazelcastInstance, MongoDatabase mongoDatabase, String collectionName) {
        this.hazelcastInstance = hazelcastInstance;
        this.mongoDatabase = mongoDatabase;
        this.collectionName = collectionName;
    }

    public void updateDocument(String documentId, Document updatedData) {
        // Get the distributed map from Hazelcast
        IMap<String, Document> documentMap = hazelcastInstance.getMap(collectionName);

        // Get the Mongo collection
        MongoCollection<Document> collection = mongoDatabase.getCollection(collectionName);

        // Retrieve the document from Hazelcast or MongoDB
        Document document = documentMap.get(documentId);
        if (document == null) {
            document = collection.find(new Document("_id", documentId)).first();
        }

        // Check if the document exists
        if (document != null) {
            // Clone the existing document to create a historical record
            Document historicalRecord = new Document(document);

            // Get the current version and increment it
            int currentVersion = document.getInteger("version");
            int newVersion = currentVersion + 1;

            // Update the version field in the document
            document.put("version", newVersion);

            // Set the updated data in the document
            document.put("data", updatedData);

            // Create a new historical record with the updated version and timestamp
            Document historicalVersion = new Document("version", currentVersion)
                    .append("timestamp", new Date())
                    .append("data", historicalRecord.get("data"));

            // Add the historical version to the history array
            ((List<Document>) historicalRecord.get("history")).add(historicalVersion);

            // Replace the document in MongoDB
            collection.replaceOne(new Document("_id", documentId), document);

            // Update the document in Hazelcast
            documentMap.put(documentId, document);

            // Insert the historical record into MongoDB
            collection.insertOne(historicalRecord);
        }
    }
}


Presentation outline:
Title: Implementing Versioning in Database
Design the schema:
In order to track the historical changes of a document/record and maintain a versioning system, keep a version field to track
the document's version. This field can be incremented with each update
